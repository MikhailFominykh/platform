# Формат кодирования фреймов

## Требования

## Контекст и постановка проблемы

Есть frame для обмена данными между клиентом и сервером, необходимо разработать формат передачи для минимизации трафика.
На данный момент используется сжатие, однако, как кажется (гипотеза) упаковка данных на основе знания их структуры
должна быть более эффективна.

- максимальный размер фрейма - 500 байт.
- криптография добавляет 25 байт
- команды создания объекта повторяют идентификатор объекта
- также каждый раз повторяется тип канала, хотя меняется он крайне редко

### Состав фрейма

- FrameId - идентификатор фрейма
    - каждый клиент тратит 60 фреймов в секунду
    - id фрейма не должен повториться за сессию (обсуждаемо, netcode к примеру это допускает)
    - u24 скорее всего хватит :-)
- Headers - управляющие заголовки
    - 7 типов (будет незначительно больше)
    - заголовков обычно мало (1-10)
- Commands - команды
    - на данный момент 30 штук, будет больше
    - направление S2C,C2S
    - объектные команды (самые частые)
        - тип канала
        - создатель команды
        - id объекта
            - id: u32
            - owner
                - room
                - user
                    - id: u16
        - id:u16 - поля

## Решение
Считаем что некоторые данные редко меняется между командами одного фрейма.
Особенно редко они меняются при создании и загрузки объекта.
К таким данным можно отнести следующее:

- ObjectId
- FieldId
- Creator
- Channel (8 вариантов)
    - Sequence
    - Group
- Command

### Формат кодирования команды

- (o, f, с, c, g, x, ch, ch, ch, ch, cmd, cmd, cmd, cmd, cmd, cmd)
    - ch - тип канала
    - cmd - тип команды
    - c 
      - 00 - используется текущий
      - 01 - равен владельцу игрового объекта
      - 11 - используется новый
- (id_object) если o = 1, иначе используется предыдущий
- (id_field) если f = 1, иначе используется предыдущий
- (id_creator) если c = 11
- (id_group) если g = 1, иначе используется предыдущая
- (data)

### Плюсы

- эффективно работает на командах создания объекта
- даст экономию на field_id для пакетов синхронизации (если field_id будет один)

### Минусы

- для посылки команды синхронизации состояния возможно потребуется сортировка команд по-пользователям



